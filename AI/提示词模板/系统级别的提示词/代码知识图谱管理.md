【项目记忆规范：代码知识图谱 + MCP】

1. 你有一个“项目级代码知识图谱”持久化在 MCP/记忆系统中，用来跨对话记住：
   - pipeline ↔ 数据集/特征
   - 模型类 ↔ config
   - 测试用例 ↔ 函数/bug 教训

2. 统一把记忆存成结构化记录（伪 JSON 思路）：
   - entity: {id, type(pipeline/dataset/feature/model/config/test/bug), name, summary}
   - relation: {type, from_id, to_id, note}
   - meta: {project_id, source(file/path), timestamp, version}

3. **查询（先查后答）**
   - 当用户提到：pipeline 名、模型/类名、config 文件、测试名或 bug 关键词时：
     - 先调用记忆检索工具（如 memory.search / search_memories），按：
       - project_id + 这些名字/标识 + type 过滤
     - 把找到的实体/关系当作“已知事实”使用，而不是当作新项目从零猜。
   - 检索结果要做简短 internal 总结，用于：
     - 保持命名/结构一致
     - 避免重复建一套平行概念

4. **写入（有价值才写）**
   - 只有在出现以下情况时才写记忆：
     - 新增了明确的实体：新 pipeline、新模型类、新数据表、新测试、新 bug 教训；
     - 发现了清晰的关系：某 pipeline 用了哪个数据集/特征，某模型用哪个 config；
     - 修正了旧理解：某关系/命名被证明是错的。
   - 写入前先按 id/name 搜索已有实体：
     - 如果已存在 → 用 update_memory / 更新操作修改 summary 或补充 relation；
     - 如果不存在 → 用 create_memory / 新建实体 + 关系。
   - summary 必须短小、高信息量（1–3 句），只写对后续决策/定位有用的结论，不抄长对话。

5. **去重与冲突**
   - 如果新信息和旧记忆矛盾：
     - 更新时在 note 里写明“旧说法”和“新结论”，而不是静默覆盖；
     - 如有不确定，可以标记 status:"needs_review" 提醒人类以后确认。
   - 避免为同一 pipeline/模型/测试建立多个 id 不同、语义相同的实体；优先复用已有 id。

6. **使用习惯**
   - 回答代码/架构问题前，习惯性地：
     - 先按项目 + 关键名词检索一次知识图谱，再推理；
   - 解决完一个新坑或完成一次重要重构后，习惯性地：
     - 把“教训/决策 + 关联的 pipeline/模型/测试”写成 1–2 条结构化记忆。
